{"componentChunkName":"component---src-templates-post-template-tsx","path":"/2021-05-15/OAuth2.0 내용과 권한 허가 과정/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<h1>OAuth 2.0</h1>\n<ul>\n<li>제 3의 앱이 자원의 소유자인 서비스 이용자를 대신하여 서비스를 요청할 수 있도록 자원 접근 권한을 위임하는 방법</li>\n<li>인증을 위한 오픈 표준 프로토콜</li>\n</ul>\n<h2>기존의 로그인 방식과 다른점? <a href=\"https://woowabros.github.io/experience/2019/03/05/aop-oauth2-redis.html\" target=\"_blank\" rel=\"nofollow\">[참고]</a></h2>\n<ul>\n<li>전통적인 웹서비스 → ID/Password로 인증을 받고 세션 유지하는 방식\n<ul>\n<li>쿠키를 지우거나, 세션 유효기간이 만료되면 재인증해야 하는 번거로움이 있다.</li>\n<li>이 방식이 나쁘다는 의미가 아니라, 사용자의 사용환경상 이 방법이 낫기 때문</li>\n<li>웹은 어디에서나 접속 가능하고, 본인만 사용하는 PC라고 확신할 수 없기 때문에,</li>\n<li>적절한 시점에 로그아웃을 해야 보안상 안전할 것이다.</li>\n</ul>\n</li>\n<li>App 사용환경 → 스마트폰은 자신만의 것\n<ul>\n<li>App - Server간 인증에서는 매번 로그아웃 하는 것은 특별한 경우가 아닌 이상 사용자에게 번거로운 경험이다.</li>\n<li>OAuth를 사용하면 최초 가입 후 로그인을 진행한 뒤, 사용자가 매번 로그인 할 필요가 없도록 하면서,</li>\n<li>인증키를 주기적으로 변경하며,</li>\n<li>사용자가 직접 재인증 하지 않아도 된다.</li>\n</ul>\n</li>\n</ul>\n<h2>OAuth 2.0 버전</h2>\n<ul>\n<li>OAuth 1.0 의 성능, 문제점을 보완</li>\n<li>보안 강화를 위해 <strong>Access Token의 Life-time을 지정하여 사용</strong></li>\n<li>Protected 자원에 접근시 HTTPS 사용</li>\n</ul>\n<h3>알아둬야 할 역할 용어</h3>\n<ol>\n<li><strong>Resource Owner</strong>\n<ul>\n<li>사용자</li>\n<li>Resource Server의 계정을 소유하고 있는 사람</li>\n<li>Protected Resource에 접근하는 권한을 제공한다.</li>\n</ul>\n</li>\n<li><strong>Resource Server (REST API)</strong>\n<ul>\n<li>OAuth 2.0 서비스를 제공하고, 자원을 관리하는 서버</li>\n<li>예 : Google, Naver, Kakao</li>\n<li>Client가 Access_token을 사용한 요청을 수신 후</li>\n<li>권한을 검증한 후 결과를 응답한다.</li>\n</ul>\n</li>\n<li><strong>Client</strong>\n<ul>\n<li>Resource Server의 API를 사용하여 데이터를 가져오려고 하는 서버 (서비스)</li>\n<li>예 : Apartalk Service, 내가 만든 사이트</li>\n<li>Resource Owner의 Protected Resource에 접근을 요청하는 Application이다.</li>\n</ul>\n</li>\n<li><strong>Authorization Server</strong>\n<ul>\n<li>Client가 Resource Server의 서비스를 사용할 수 있게 인증</li>\n<li>토큰을 발행해주는 서버</li>\n<li>예: Google, Naver, Kakao의 인증 서버</li>\n<li>Client가 성공적으로 Access_Token을 발급 받은 이후</li>\n<li>Resource Owner를 인증하고, 권한 부여를 한다.</li>\n</ul>\n</li>\n</ol>\n<h3>권한 허가를 위한 절차(Protocol Flow) <a href=\"https://blog.weirdx.io/post/39955\" target=\"_blank\" rel=\"nofollow\">[참고]</a></h3>\n<ul>\n<li>앞에서 소개한 4가지 역할들이 서로 상호작용을 통해 허가 절차가 진행된다.</li>\n</ul>\n<ol>\n<li><strong>[Request]</strong> <strong>Authorization ( Client → Resource Owner )</strong>\n<ul>\n<li>Client가 Resource Owner에게 권한 요청을 한다.</li>\n<li>요청 방법\n<ol>\n<li>Resource Owner에게 직접 요청</li>\n<li>Resource Server를 통해 간접 요청</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><strong>[Response]</strong> <strong>Authorization Grant ( Resource Owner → Client )</strong>\n<ul>\n<li>Resource Owner가 권한을 허가하면, Client는 Authorization Grant를 발급 받는다.</li>\n<li>Authorization Grant : Resource Owner가 자원에 접급할 수 있는 권하는 부여했다는 확인증\n<ul>\n<li>Client가 Access_Token을 요청하여 얻어오는데 사용된다.</li>\n<li>Authorization Grant는 4개의 Type이 있다. <a href=\"https://gdtbgl93.tistory.com/181\" target=\"_blank\" rel=\"nofollow\">[참고]</a>\n<ol>\n<li><strong>Authorization Code</strong>\n<ul>\n<li>자신만의 백엔드 서버를 갖고 동작하는 서비스일 경우</li>\n</ul>\n</li>\n<li><strong>Implicit</strong>\n<ul>\n<li>위의 Authorization Code에서 인증 코드 교환 과정을 빼고 바로 Access_Token 발급</li>\n<li>Authorization Code와 마찬가지로 브라우저를 띄워 사용자에게 승인을 요구한다.</li>\n</ul>\n</li>\n<li><strong>Resource Owner Password Credentials</strong>\n<ul>\n<li>자신이 자신의 권한 서버에 접속할 경우 (신뢰할 수 있는 Client)</li>\n<li>예: 카카오 앱에서 카카오 인증을 한다.</li>\n</ul>\n</li>\n<li><strong>Client Credentials</strong>\n<ul>\n<li>사용자 인증 및 권한부여 X</li>\n<li>대신, 해당 앱이나 서비스 자체에 인증 및 권한부여</li>\n<li>위의 경우 보통 Firebase와 같은 PaaS 서비스 사용</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>[Request] Access_Token ( Client → Authorization Server )</strong>\n<ul>\n<li>Authorization Grant를 받은 Client는 Authorization 서버에 Access_Token을 요청한다.</li>\n</ul>\n</li>\n<li><strong>[Response] Access_Token ( Authorization Server → Client )</strong>\n<ul>\n<li>요청을 받은 Authorization Server는 Client가 보내준 Authorization Grant의 유효성을 검증한다.</li>\n<li>유효하다면, Access_Token을 발급하여 결과를 Client에 전달한다.</li>\n</ul>\n</li>\n<li><strong>[Request] Resource ( Client → Resource Server )</strong>\n<ul>\n<li>Access_Token을 받은 Client는 토큰과 함께 Resource Server에 자원을 요청한다.</li>\n</ul>\n</li>\n<li><strong>[Response] Protected Resource ( Resource Server → Client )</strong>\n<ul>\n<li>요청 받은 Resource Server는 Access_Token의 유효성을 검증한다.</li>\n<li>유효하다면, 요청에 맞는 처리를 하여 결과를 Client에게 전달한다.</li>\n</ul>\n</li>\n</ol>\n<h3>Access_Token과 Refresh_Token?</h3>\n<ul>\n<li>\n<p><strong>Access_Token</strong></p>\n<ul>\n<li>Authorization Server로부터 요청 절차를 정상적으로 종료한 Client에게 발급된다.</li>\n<li>인증에 필요한 형태(id, password 등)을 토큰으로 표현</li>\n<li>문자열 형태</li>\n<li>Resource Server는 여러가지 인증 방식에 각각 대응하지 않아도 권한을 확인 할 수 있게 된다.</li>\n<li><strong>한번 발급받은 Access_Token은 사용 시간이 제한되어 있다.</strong></li>\n</ul>\n</li>\n<li>\n<p><strong>Refresh_Token</strong></p>\n<ul>\n<li><strong>Access_Token 사용 시간이 만료되면 새로운 Access_Token을 얻기 위해 활용된다.</strong></li>\n<li>Authorization Server로부터 Access_Token을 발급 받는 시점에 Refresh_Token도 함께 발급된다.</li>\n<li>Client는 별도의 발급 절차 없이 Refresh_Token을 미리 가지고 있을 수 있다.</li>\n<li>Authorization Server에서만 활용되며 Resource Server에는 전송되지 않는다.</li>\n<li>일정 시간이 흘러 Access_Token이 만료되면\n<ol>\n<li>Resource Server는 이후 요청에 대해 오류를 응답한다.</li>\n<li>Client는 오류를 받고 Access_Token이 만료되었음을 알게 된다.</li>\n<li>Client는 전에 받았던 Refresh_Token을 Authorization Server에 보내 새로운 Access_Token을 요청한다.</li>\n<li>요청을 받은 Authorization Server는 Refresh_Token의 유효성 검증 후, 새로운 Access_Token을 발급한다.</li>\n<li>이 과정에 옵션에 따라 Refresh_Token도 새로 발급 받을 수 있다.</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h3>기타 참고사항</h3>\n<ul>\n<li><a href=\"https://www.youtube.com/watch?v=PIlP_YX5HK8&#x26;list=LL&#x26;index=1\" target=\"_blank\" rel=\"nofollow\">Youtube - [생활코딩] OAuth 2.0 : 동작 메커니즘</a></li>\n<li><a href=\"https://woowabros.github.io/experience/2019/03/05/aop-oauth2-redis.html\" target=\"_blank\" rel=\"nofollow\">우아한형제들 - 기술블로그 : AOP를 이용한 OAuth2 캐시 적용하기</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=mPB2CZiAkKM\" target=\"_blank\" rel=\"nofollow\">우아한테크세미나 : 우아한레디스 by 강대명님</a></li>\n<li><a href=\"https://flask-oauthlib.readthedocs.io/en/latest/client.html\" target=\"_blank\" rel=\"nofollow\">Flask-OAuthlib : Client</a></li>\n<li><a href=\"https://tools.ietf.org/html/rfc6749#section-4.3\" target=\"_blank\" rel=\"nofollow\">RFC 6749 - OAuth 2.0</a></li>\n</ul>","frontmatter":{"title":"OAuth2.0 내용과 권한 허가 과정","summary":"OAuth와 인증/인가 이야기","date":"2021.05.15.","categories":["OAuth","인증","인가"]}}}]}},"pageContext":{"slug":"/2021-05-15/OAuth2.0 내용과 권한 허가 과정/"}},"staticQueryHashes":[],"slicesMap":{}}